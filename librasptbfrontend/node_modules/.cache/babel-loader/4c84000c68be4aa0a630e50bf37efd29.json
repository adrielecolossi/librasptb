{"ast":null,"code":"import { statSync, createReadStream, promises as fs } from 'node:fs';\nimport { basename } from 'node:path';\nimport { MessageChannel } from 'node:worker_threads';\nimport File from './file.js';\nimport Blob from './index.js';\nconst {\n  stat\n} = fs;\n\nconst DOMException = globalThis.DOMException || (() => {\n  const port = new MessageChannel().port1;\n  const ab = new ArrayBuffer(0);\n\n  try {\n    port.postMessage(ab, [ab, ab]);\n  } catch (err) {\n    return err.constructor;\n  }\n})();\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\n\n\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type);\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\n\n\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\n\n\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\n\n\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type); // @ts-ignore\n\n\nconst fromBlob = function (stat, path) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return new Blob([new BlobDataItem({\n    path,\n    size: stat.size,\n    lastModified: stat.mtimeMs,\n    start: 0\n  })], {\n    type\n  });\n}; // @ts-ignore\n\n\nconst fromFile = function (stat, path) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return new File([new BlobDataItem({\n    path,\n    size: stat.size,\n    lastModified: stat.mtimeMs,\n    start: 0\n  })], basename(path), {\n    type,\n    lastModified: stat.mtimeMs\n  });\n};\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\n\n\nclass BlobDataItem {\n  #path;\n  #start;\n\n  constructor(options) {\n    this.#path = options.path;\n    this.#start = options.start;\n    this.size = options.size;\n    this.lastModified = options.lastModified;\n  }\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n\n\n  slice(start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start\n    });\n  }\n\n  async *stream() {\n    const {\n      mtimeMs\n    } = await stat(this.#path);\n\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError');\n    }\n\n    yield* createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n\n}\n\nexport default blobFromSync;\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync };","map":{"version":3,"sources":["C:/Users/Adriele/OneDrive/Área de Trabalho/librasptbsite/librasptbfrontend/node_modules/fetch-blob/from.js"],"names":["statSync","createReadStream","promises","fs","basename","MessageChannel","File","Blob","stat","DOMException","globalThis","port","port1","ab","ArrayBuffer","postMessage","err","constructor","blobFromSync","path","type","fromBlob","blobFrom","then","fileFrom","fromFile","fileFromSync","BlobDataItem","size","lastModified","mtimeMs","start","options","slice","end","stream","Symbol","toStringTag"],"mappings":"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","sourcesContent":["import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport { MessageChannel } from 'node:worker_threads'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\nconst DOMException = globalThis.DOMException || (() => {\n  const port = new MessageChannel().port1\n  const ab = new ArrayBuffer(0)\n  try { port.postMessage(ab, [ab, ab]) } catch (err) { return err.constructor }\n})()\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n"]},"metadata":{},"sourceType":"module"}