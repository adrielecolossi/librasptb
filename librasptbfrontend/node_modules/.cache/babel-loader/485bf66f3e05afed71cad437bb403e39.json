{"ast":null,"code":"/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\nimport './streams.cjs';\n/** @typedef {import('buffer').Blob} NodeBlob} */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\n\nconst POOL_SIZE = 65536;\n/** @param {(Blob | NodeBlob | Uint8Array)[]} parts */\n\nasync function* toIterator(parts) {\n  let clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield* part.stream();\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset;\n        const end = part.byteOffset + part.byteLength;\n\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE);\n          const chunk = part.buffer.slice(position, position + size);\n          position += chunk.byteLength;\n          yield new Uint8Array(chunk);\n        }\n      } else {\n        yield part;\n      }\n    } else {\n      /* c8 ignore start */\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0;\n\n      while (position !== part.size) {\n        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));\n        const buffer = await chunk.arrayBuffer();\n        position += buffer.byteLength;\n        yield new Uint8Array(buffer);\n      }\n      /* c8 ignore end */\n\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = [];\n  #type = '';\n  #size = 0;\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string }} [options]\n   */\n\n  constructor() {\n    let blobParts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.');\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.');\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.');\n    }\n\n    if (options === null) options = {};\n    const encoder = new TextEncoder();\n\n    for (const element of blobParts) {\n      let part;\n\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0));\n      } else if (element instanceof Blob) {\n        part = element;\n      } else {\n        part = encoder.encode(element);\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;\n      this.#parts.push(part);\n    }\n\n    const type = options.type === undefined ? '' : String(options.type);\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : '';\n  }\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n\n\n  get size() {\n    return this.#size;\n  }\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n\n\n  get type() {\n    return this.#type;\n  }\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n\n\n  async text() {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder();\n    let str = '';\n\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, {\n        stream: true\n      });\n    } // Remaining\n\n\n    str += decoder.decode();\n    return str;\n  }\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  async arrayBuffer() {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n    const data = new Uint8Array(this.size);\n    let offset = 0;\n\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset);\n      offset += chunk.length;\n    }\n\n    return data.buffer;\n  }\n\n  stream() {\n    const it = toIterator(this.#parts, true);\n    return new globalThis.ReadableStream({\n      type: 'bytes',\n\n      async pull(ctrl) {\n        const chunk = await it.next();\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n      },\n\n      async cancel() {\n        await it.return();\n      }\n\n    });\n  }\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n\n\n  slice() {\n    let start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const {\n      size\n    } = this;\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    const parts = this.#parts;\n    const blobParts = [];\n    let added = 0;\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break;\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size;\n        relativeEnd -= size;\n      } else {\n        let chunk;\n\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.byteLength;\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.size;\n        }\n\n        relativeEnd -= size;\n        blobParts.push(chunk);\n        relativeStart = 0; // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], {\n      type: String(type).toLowerCase()\n    });\n    blob.#size = span;\n    blob.#parts = blobParts;\n    return blob;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n\n  static [Symbol.hasInstance](object) {\n    return object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n  }\n\n};\n\nObject.defineProperties(_Blob.prototype, {\n  size: {\n    enumerable: true\n  },\n  type: {\n    enumerable: true\n  },\n  slice: {\n    enumerable: true\n  }\n});\n/** @type {typeof globalThis.Blob} */\n\nexport const Blob = _Blob;\nexport default Blob;","map":{"version":3,"sources":["C:/Users/Adriele/OneDrive/Área de Trabalho/librasptbsite/librasptbfrontend/node_modules/fetch-blob/index.js"],"names":["POOL_SIZE","toIterator","parts","clone","part","stream","ArrayBuffer","isView","position","byteOffset","end","byteLength","size","Math","min","chunk","buffer","slice","Uint8Array","arrayBuffer","_Blob","Blob","type","constructor","blobParts","options","TypeError","Symbol","iterator","encoder","TextEncoder","element","encode","push","undefined","String","test","text","decoder","TextDecoder","str","decode","data","offset","set","length","it","globalThis","ReadableStream","pull","ctrl","next","done","close","enqueue","value","cancel","return","start","relativeStart","max","relativeEnd","span","added","subarray","blob","toLowerCase","toStringTag","hasInstance","object","Object","defineProperties","prototype","enumerable"],"mappings":"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","sourcesContent":["/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n/** @typedef {import('buffer').Blob} NodeBlob} */\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | NodeBlob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * part.stream()\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    } else {\n      /* c8 ignore start */\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0\n      while (position !== part.size) {\n        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n      /* c8 ignore end */\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(element)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    const type = options.type === undefined ? '' : String(options.type)\n\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n"]},"metadata":{},"sourceType":"module"}