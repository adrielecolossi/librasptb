{"ast":null,"code":"/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\nimport Stream, { PassThrough } from 'node:stream';\nimport { types, deprecate } from 'node:util';\nimport Blob from 'fetch-blob';\nimport { FormData, formDataToBlob } from 'formdata-polyfill/esm.min.js';\nimport { FetchError } from './errors/fetch-error.js';\nimport { FetchBaseError } from './errors/base.js';\nimport { isBlob, isURLSearchParameters } from './utils/is.js';\nconst INTERNALS = Symbol('Body internals');\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\n\nexport default class Body {\n  constructor(body) {\n    let {\n      size = 0\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let boundary = null;\n\n    if (body === null) {\n      // Body is undefined or null\n      body = null;\n    } else if (isURLSearchParameters(body)) {\n      // Body is a URLSearchParams\n      body = Buffer.from(body.toString());\n    } else if (isBlob(body)) {// Body is blob\n    } else if (Buffer.isBuffer(body)) {// Body is Buffer\n    } else if (types.isAnyArrayBuffer(body)) {\n      // Body is ArrayBuffer\n      body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n      // Body is ArrayBufferView\n      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof Stream) {// Body is stream\n    } else if (body instanceof FormData) {\n      // Body is FormData\n      body = formDataToBlob(body);\n      boundary = body.type.split('=')[1];\n    } else {\n      // None of the above\n      // coerce to string then buffer\n      body = Buffer.from(String(body));\n    }\n\n    let stream = body;\n\n    if (Buffer.isBuffer(body)) {\n      stream = Stream.Readable.from(body);\n    } else if (isBlob(body)) {\n      stream = Stream.Readable.from(body.stream());\n    }\n\n    this[INTERNALS] = {\n      body,\n      stream,\n      boundary,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n\n    if (body instanceof Stream) {\n      body.on('error', error_ => {\n        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n\n  get body() {\n    return this[INTERNALS].stream;\n  }\n\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n\n\n  async arrayBuffer() {\n    const {\n      buffer,\n      byteOffset,\n      byteLength\n    } = await consumeBody(this);\n    return buffer.slice(byteOffset, byteOffset + byteLength);\n  }\n\n  async formData() {\n    const ct = this.headers.get('content-type');\n\n    if (ct.startsWith('application/x-www-form-urlencoded')) {\n      const formData = new FormData();\n      const parameters = new URLSearchParams(await this.text());\n\n      for (const [name, value] of parameters) {\n        formData.append(name, value);\n      }\n\n      return formData;\n    }\n\n    const {\n      toFormData\n    } = await import('./utils/multipart-parser.js');\n    return toFormData(this.body, ct);\n  }\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n\n\n  async blob() {\n    const ct = this.headers && this.headers.get('content-type') || this[INTERNALS].body && this[INTERNALS].body.type || '';\n    const buf = await this.buffer();\n    return new Blob([buf], {\n      type: ct\n    });\n  }\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n\n\n  async json() {\n    const buffer = await consumeBody(this);\n    return JSON.parse(buffer.toString());\n  }\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n\n\n  async text() {\n    const buffer = await consumeBody(this);\n    return buffer.toString();\n  }\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n\n\n  buffer() {\n    return consumeBody(this);\n  }\n\n}\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer'); // In browsers, all properties are enumerable.\n\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  }\n});\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\n\nasync function consumeBody(data) {\n  if (data[INTERNALS].disturbed) {\n    throw new TypeError(`body used already for: ${data.url}`);\n  }\n\n  data[INTERNALS].disturbed = true;\n\n  if (data[INTERNALS].error) {\n    throw data[INTERNALS].error;\n  }\n\n  const {\n    body\n  } = data; // Body is null\n\n  if (body === null) {\n    return Buffer.alloc(0);\n  }\n  /* c8 ignore next 3 */\n\n\n  if (!(body instanceof Stream)) {\n    return Buffer.alloc(0);\n  } // Body is stream\n  // get ready to actually consume the body\n\n\n  const accum = [];\n  let accumBytes = 0;\n\n  try {\n    for await (const chunk of body) {\n      if (data.size > 0 && accumBytes + chunk.length > data.size) {\n        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n        body.destroy(error);\n        throw error;\n      }\n\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    }\n  } catch (error) {\n    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n    throw error_;\n  }\n\n  if (body.readableEnded === true || body._readableState.ended === true) {\n    try {\n      if (accum.every(c => typeof c === 'string')) {\n        return Buffer.from(accum.join(''));\n      }\n\n      return Buffer.concat(accum, accumBytes);\n    } catch (error) {\n      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n    }\n  } else {\n    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n  }\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\n\n\nexport const clone = (instance, highWaterMark) => {\n  let p1;\n  let p2;\n  let {\n    body\n  } = instance[INTERNALS]; // Don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // Check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // Tee instance body\n    p1 = new PassThrough({\n      highWaterMark\n    });\n    p2 = new PassThrough({\n      highWaterMark\n    });\n    body.pipe(p1);\n    body.pipe(p2); // Set instance body to teed body and return the other teed body\n\n    instance[INTERNALS].stream = p1;\n    body = p2;\n  }\n\n  return body;\n};\nconst getNonSpecFormDataBoundary = deprecate(body => body.getBoundary(), 'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package', 'https://github.com/node-fetch/node-fetch/issues/1167');\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\n\nexport const extractContentType = (body, request) => {\n  // Body is null or undefined\n  if (body === null) {\n    return null;\n  } // Body is string\n\n\n  if (typeof body === 'string') {\n    return 'text/plain;charset=UTF-8';\n  } // Body is a URLSearchParams\n\n\n  if (isURLSearchParameters(body)) {\n    return 'application/x-www-form-urlencoded;charset=UTF-8';\n  } // Body is blob\n\n\n  if (isBlob(body)) {\n    return body.type || null;\n  } // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\n\n  if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n    return null;\n  }\n\n  if (body instanceof FormData) {\n    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getBoundary === 'function') {\n    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n  } // Body is stream - can't really do much about this\n\n\n  if (body instanceof Stream) {\n    return null;\n  } // Body constructor defaults other things to string\n\n\n  return 'text/plain;charset=UTF-8';\n};\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\n\nexport const getTotalBytes = request => {\n  const {\n    body\n  } = request[INTERNALS]; // Body is null or undefined\n\n  if (body === null) {\n    return 0;\n  } // Body is Blob\n\n\n  if (isBlob(body)) {\n    return body.size;\n  } // Body is Buffer\n\n\n  if (Buffer.isBuffer(body)) {\n    return body.length;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getLengthSync === 'function') {\n    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n  } // Body is stream\n\n\n  return null;\n};\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {void}\n */\n\nexport const writeToStream = (dest, _ref) => {\n  let {\n    body\n  } = _ref;\n\n  if (body === null) {\n    // Body is null\n    dest.end();\n  } else {\n    // Body is stream\n    body.pipe(dest);\n  }\n};","map":{"version":3,"sources":["C:/Users/Adriele/OneDrive/Área de Trabalho/librasptbsite/librasptbfrontend/node_modules/node-fetch/src/body.js"],"names":["Stream","PassThrough","types","deprecate","Blob","FormData","formDataToBlob","FetchError","FetchBaseError","isBlob","isURLSearchParameters","INTERNALS","Symbol","Body","constructor","body","size","boundary","Buffer","from","toString","isBuffer","isAnyArrayBuffer","ArrayBuffer","isView","buffer","byteOffset","byteLength","type","split","String","stream","Readable","disturbed","error","on","error_","url","message","bodyUsed","arrayBuffer","consumeBody","slice","formData","ct","headers","get","startsWith","parameters","URLSearchParams","text","name","value","append","toFormData","blob","buf","json","JSON","parse","prototype","Object","defineProperties","enumerable","data","TypeError","alloc","accum","accumBytes","chunk","length","destroy","push","readableEnded","_readableState","ended","every","c","join","concat","clone","instance","highWaterMark","p1","p2","Error","getBoundary","pipe","getNonSpecFormDataBoundary","extractContentType","request","getTotalBytes","getLengthSync","hasKnownLength","writeToStream","dest","end"],"mappings":"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","sourcesContent":["\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'node:stream';\nimport {types, deprecate} from 'node:util';\n\nimport Blob from 'fetch-blob';\nimport {FormData, formDataToBlob} from 'formdata-polyfill/esm.min.js';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {isBlob, isURLSearchParameters} from './utils/is.js';\n\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (body instanceof FormData) {\n\t\t\t// Body is FormData\n\t\t\tbody = formDataToBlob(body);\n\t\t\tboundary = body.type.split('=')[1];\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tlet stream = body;\n\n\t\tif (Buffer.isBuffer(body)) {\n\t\t\tstream = Stream.Readable.from(body);\n\t\t} else if (isBlob(body)) {\n\t\t\tstream = Stream.Readable.from(body.stream());\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tstream,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].stream;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\tasync formData() {\n\t\tconst ct = this.headers.get('content-type');\n\n\t\tif (ct.startsWith('application/x-www-form-urlencoded')) {\n\t\t\tconst formData = new FormData();\n\t\t\tconst parameters = new URLSearchParams(await this.text());\n\n\t\t\tfor (const [name, value] of parameters) {\n\t\t\t\tformData.append(name, value);\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\tconst {toFormData} = await import('./utils/multipart-parser.js');\n\t\treturn toFormData(this.body, ct);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.buffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn JSON.parse(buffer.toString());\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tconst {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance[INTERNALS];\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].stream = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\nconst getNonSpecFormDataBoundary = deprecate(\n\tbody => body.getBoundary(),\n\t'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package',\n\t'https://github.com/node-fetch/node-fetch/issues/1167'\n);\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\tif (body instanceof FormData) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request[INTERNALS];\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {void}\n */\nexport const writeToStream = (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tbody.pipe(dest);\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}